# Задачи на паттерны конкурентности

## Задача 1

Реализовать Fan-In.

```go showLineNumbers filename="main.go"
package main

func fanin(chans ...<-chan int) <-chan int {
}
```

<details>
  <summary>**Ответ**</summary>

```go showLineNumbers filename="main.go"
package main

import "sync"

func fanin(chans ...<-chan int) <-chan int {
	results := make(chan int)
	wg := sync.WaitGroup{}

	for _, ch := range chans {
		wg.Add(1)
		go func() {
			defer wg.Done()

			for val := range ch {
				results <- val
			}
		}()
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	return results
}
```

</details>

## Задача 2

Что выведет код?

Нужно распараллелить запросы.

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"time"
)

type User struct {
	Name string
}

func fetch(_ context.Context, user User) (string, error) {
	time.Sleep(time.Millisecond * 10)

	return user.Name, nil
}

func process(ctx context.Context, users []User) (map[string]int64, error) {
	names := make(map[string]int64, 0)

	for _, u := range users {
		name, err := fetch(ctx, u)
		if err != nil {
		}

		names[name] = names[name] + 1
	}

	return names, nil
}

func main() {
	names := []User{
		{"Ann"},
		{"Bob"},
		{"Cindy"},
		{"Bob"},
	}

	ctx := context.Background()

	start := time.Now()
	res, err := process(ctx, names)
	if err != nil {
		fmt.Println("an error occurred:", err.Error())
	}
	fmt.Println("time:", time.Since(start))
	fmt.Println(res)
}
```

<details>
  <summary>**Ответ**</summary>

Время выполнения примерно чуть больше 40мс и map[Ann:1 Bob:2 Cindy:1]

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"golang.org/x/sync/errgroup"
)

type User struct {
	Name string
}

func fetch(ctx context.Context, user User) (string, error) {
	ch := make(chan any)

	go func() {
		time.Sleep(time.Millisecond * 10)
		close(ch)
	}()

	select {
	case <-ch:
		return user.Name, nil
	case <-ctx.Done():
		return "", errors.New("context canceled")
	}
}

func process(ctx context.Context, users []User) (map[string]int64, error) {
	names := make(map[string]int64, 0)
	mu := sync.Mutex{}

	egroup, ectx := errgroup.WithContext(ctx)
	egroup.SetLimit(10) // Опционально, если нужно ограничить количество горутин

	for _, u := range users {
		egroup.Go(func() error {
			name, err := fetch(ectx, u)
			if err != nil {
				return err
			}

			mu.Lock()
			defer mu.Unlock()
			names[name] = names[name] + 1

			return nil
		})
	}

	if err := egroup.Wait(); err != nil {
		return nil, err
	}

	return names, nil
}

func main() {
	names := []User{
		{"Ann"},
		{"Bob"},
		{"Cindy"},
		{"Bob"},
	}

	ctx := context.Background()

	start := time.Now()
	res, err := process(ctx, names)
	if err != nil {
		fmt.Println("an error occurred:", err.Error())
	}
	fmt.Println("time:", time.Since(start))
	fmt.Println(res)
}
```

</details>

## Задача 3

Реализовать Rate Limiter.

Условия могут быть разные:

- Ограничение кол-ва коннектов
- Ограничение кол-ва горутин
- Ограничение RPS

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"strconv"
	"time"
)

type Request struct {
	Payload string
}

type client struct {
}

func (c client) SendRequest(ctx context.Context, request Request) error {
	time.Sleep(100 * time.Millisecond)
	fmt.Println("sending request", request.Payload)
	return nil
}

func (c client) WithLimiter(ctx context.Context, requests []Request) {
}

func main() {
	ctx := context.Background()
	c := client{}
	requests := make([]Request, 1000)
	for i := 0; i < 1000; i++ {
		requests[i] = Request{
			Payload: strconv.Itoa(i),
		}
	}
	c.WithLimiter(ctx, requests)
}
```

<details>
  <summary>**Ответ**</summary>

**Ограничение кол-ва коннектов**

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"strconv"
	"sync"
	"time"
)

type Request struct {
	Payload string
}

type client struct {
}

func (c client) SendRequest(ctx context.Context, request Request) error {
	time.Sleep(100 * time.Millisecond)
	fmt.Println("sending request", request.Payload)
	return nil
}

var maxConnects = 10

func (c client) WithLimiter(ctx context.Context, ch chan Request) {
	wg := sync.WaitGroup{}
	wg.Add(maxConnects)
	for range maxConnects {
		go func() {
			defer wg.Done()

			for req := range ch {
				c.SendRequest(ctx, req)
			}
		}()
	}
	wg.Wait()
}

func main() {
	ctx := context.Background()
	c := client{}
	requests := make([]Request, 1000)
	for i := 0; i < 1000; i++ {
		requests[i] = Request{
			Payload: strconv.Itoa(i),
		}
	}
	c.WithLimiter(ctx, generate(requests))
}

func generate(reqs []Request) chan Request {
	ch := make(chan Request)

	go func() {
		for _, v := range reqs {
			ch <- v
		}
		close(ch)
	}()

	return ch
}
```

**Ограничение кол-ва горутин**

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"strconv"
	"time"
)

type Request struct {
	Payload string
}

type client struct {
}

func (c client) SendRequest(ctx context.Context, request Request) error {
	time.Sleep(100 * time.Millisecond)
	fmt.Println("sending request", request.Payload)
	return nil
}

var maxGoroutines = 100

func (c client) WithLimiter(ctx context.Context, requests []Request) {
	tokens := make(chan struct{}, maxGoroutines)

	go func() {
		for range maxGoroutines {
			tokens <- struct{}{}
		}
	}()

	for _, req := range requests {
		<-tokens
		go func() {
			defer func() {
				tokens <- struct{}{}
			}()

			c.SendRequest(ctx, req)
		}()
	}

	for range maxGoroutines {
		<-tokens
	}
}

func main() {
	ctx := context.Background()
	c := client{}
	requests := make([]Request, 1000)
	for i := 0; i < 1000; i++ {
		requests[i] = Request{
			Payload: strconv.Itoa(i),
		}
	}
	c.WithLimiter(ctx, requests)
}
```

**Ограничение RPS**

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"strconv"
	"sync"
	"time"
)

type Request struct {
	Payload string
}

type client struct {
}

func (c client) SendRequest(ctx context.Context, request Request) error {
	time.Sleep(100 * time.Millisecond)
	fmt.Println("sending request", request.Payload)
	return nil
}

var rps = 100
var burst = 10

func (c client) WithLimiter(ctx context.Context, requests []Request) {
	ticker := time.NewTicker(time.Second / time.Duration(rps))
	tickets := make(chan struct{}, burst)

	wg := sync.WaitGroup{}

	go func() {
		for range burst {
			tickets <- struct{}{}
		}
	}()

	go func() {
		for {
			select {
			case <-ticker.C:
				tickets <- struct{}{}
			case <-ctx.Done():
				return
			}
		}
	}()

	wg.Add(len(requests))
	for _, request := range requests {
		<-tickets
		go func() {
			defer wg.Done()

			c.SendRequest(ctx, request)
		}()
	}
	wg.Wait()
}

func main() {
	ctx := context.Background()
	c := client{}
	requests := make([]Request, 1000)
	for i := 0; i < 1000; i++ {
		requests[i] = Request{
			Payload: strconv.Itoa(i),
		}
	}
	c.WithLimiter(ctx, requests)
}
```

</details>

## Задача 4

Реализовать параллельные запросы по адресам из списка.

Подсчитать количество для каждого StatusCode ответа.

Предусмотреть возможность отмены запроса по таймауту.

```go showLineNumbers filename="main.go"
package main

func main() {
	urls := []string{
		"https://google.com",
		"https://yandex.ru",
		"https://amazon.com",
		"https://youtube.com",
	}

	process(urls)
}

func process(urls []string) {
}
```

<details>
  <summary>**Ответ**</summary>

**Вариант без Rate Limiter**

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"net/http"
	"sync"
	"time"
)

func main() {
	urls := []string{
		"https://google.com",
		"https://yandex.ru",
		"https://amazon.com",
		"https://youtube.com",
	}

	fmt.Println(process(urls))
}

var client http.Client

func process(urls []string) map[int]int {
	statusCodeCounts := make(map[int]int)
	wg := sync.WaitGroup{}
	mu := sync.Mutex{}

	wg.Add(len(urls))
	for _, url := range urls {
		go func() {
			defer wg.Done()

			ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
			defer cancel()

			req, _ := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)

			resp, err := client.Do(req)
			if err != nil {
				fmt.Println("error occurred:", err.Error())
				return
			}

			mu.Lock()
			statusCodeCounts[resp.StatusCode]++
			mu.Unlock()
		}()
	}
	wg.Wait()

	return statusCodeCounts
}
```

**Вариант c Rate Limiter**

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"net/http"
	"sync"
	"time"
)

func main() {
	urls := []string{
		"https://google.com",
		"https://yandex.ru",
		"https://amazon.com",
		"https://youtube.com",
	}

	fmt.Println(process(urls))
}

var client http.Client

var maxConnects = 10

func process(urls []string) map[int]int {
	statusCodeCounts := make(map[int]int)
	wg := sync.WaitGroup{}
	mu := sync.Mutex{}

	ch := make(chan string)

	go func() {
		for _, url := range urls {
			ch <- url
		}
		close(ch)
	}()

	processUrl := func(url string) {
		ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
		defer cancel()

		req, _ := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)

		resp, err := client.Do(req)
		if err != nil {
			fmt.Println("error occurred:", err.Error())
			return
		}

		mu.Lock()
		statusCodeCounts[resp.StatusCode]++
		mu.Unlock()
	}

	wg.Add(maxConnects)
	for range maxConnects {
		go func() {
			defer wg.Done()

			for url := range ch {
				processUrl(url)
			}
		}()
	}
	wg.Wait()

	return statusCodeCounts
}
```

</details>

## Задача 5

Реализовать Worker Pool.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

func say(id int, phrase string) {
	time.Sleep(20 * time.Microsecond)
	fmt.Printf("Worker %d says: %s\n", id, phrase)
}

func makePool(poolSize int, handler func(int, string)) (func(string), func()) {
}

func main() {
	phrases := []string{}

	for i := range 100 {
		phrases = append(phrases, fmt.Sprintf("phrase %d", i))
	}

	handle, wait := makePool(5, say)

	for _, phrase := range phrases {
		handle(phrase)
	}

	wait()

	fmt.Println("Done!")
}
```

<details>
  <summary>**Ответ**</summary>

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

func say(id int, phrase string) {
	time.Sleep(20 * time.Microsecond)
	fmt.Printf("Worker %d says: %s\n", id, phrase)
}

func makePool(poolSize int, handler func(int, string)) (func(string), func()) {
	pool := make(chan int, poolSize)

	for i := range poolSize {
		pool <- i
	}

	handle := func(s string) {
		id := <-pool
		go func() {
			defer func() {
				pool <- id
			}()

			handler(id, s)
		}()
	}

	wait := func() {
		for range poolSize {
			<-pool
		}
	}

	return handle, wait
}

func main() {
	phrases := []string{}

	for i := range 100 {
		phrases = append(phrases, fmt.Sprintf("phrase %d", i))
	}

	handle, wait := makePool(5, say)

	for _, phrase := range phrases {
		handle(phrase)
	}

	wait()

	fmt.Println("Done!")
}
```

</details>
