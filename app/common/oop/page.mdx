# ООП

Объектно-ориентированное программирование (ООП) — это подход к разработке программ, основанный на концепции объектов, которые инкапсулируют данные и поведение. Основные принципы ООП включают наследование, полиморфизм, инкапсуляцию и абстракцию.

**Особенности ООП в Go:**

Go не является классическим объектно-ориентированным языком (нет классов, наследования в традиционном понимании), но поддерживает ключевые концепции ООП через структуры, интерфейсы и композицию.

## Основные принципы ООП в Go

### 1. Наследование

- **Наследование** в Go не реализовано в классическом смысле (как `extends` в других языках).
- Вместо этого используется **композиция**, которая позволяет "вкладывать" одну структуру в другую.

**Особенности:**

- Композиция считается более гибким и предпочтительным подходом, так как уменьшает сильную связанность компонентов.
- Наследование заменяется вложением структур.

**Различия между композицией и наследованием:**

| **Наследование**             | **Композиция**                       |
| ---------------------------- | ------------------------------------ |
| Сильно связанная модель.     | Слабая связь между структурами.      |
| Один класс наследует другой. | Структура включает другие структуры. |
| Труднее модифицировать.      | Гибче в управлении.                  |

### 2. Полиморфизм

- Полиморфизм в Go достигается с помощью **интерфейсов**.
- **Интерфейс** — это набор методов, которые может реализовать любой тип.
- Функции и методы могут работать с интерфейсами вместо конкретных типов, что позволяет использовать разные типы с одинаковым интерфейсом.

**Особенности:**

- Интерфейсы позволяют реализовать принцип "поведение вместо структуры".
- Полиморфизм используется для разделения логики на слои.

**Пример применения:**

- Реализация разных способов хранения данных (например, в памяти, файлах, базе данных) через единый интерфейс.

### 3. Инкапсуляция

- Инкапсуляция в Go достигается с помощью **регистра букв**:
  - Поля и методы, начинающиеся с **заглавной буквы**, являются **публичными** (экспортируемыми).
  - Поля и методы, начинающиеся с **маленькой буквы**, являются **приватными** (неэкспортируемыми).

**Особенности:**

- Это позволяет скрывать детали реализации и предоставлять только необходимый внешний интерфейс.
- Обеспечивает изоляцию сложной логики внутри объекта.

### 4. Абстракция

- Абстракция достигается через интерфейсы.
- Позволяет определить "контракт", который должны реализовывать разные типы, не заботясь о конкретной реализации.

### Особенности ООП в Go

1. **Отсутствие классов:** Вместо них используются структуры (`struct`) и методы.
2. **Вложение структур (композиция):** Структура может включать в себя другую структуру, наследуя её поведение.
3. **Интерфейсы:** Гибкий механизм для определения поведения. Тип автоматически реализует интерфейс, если у него есть все методы, определённые в этом интерфейсе.
4. **Отсутствие конструктора:** Конструкторы в Go заменяются функциями, которые возвращают указатель на структуру.

### Преимущества ООП в Go

1. **Простота:** Упрощённый подход к ООП через композицию и интерфейсы.
2. **Гибкость:** Полиморфизм через интерфейсы позволяет разделять логику и легко модифицировать поведение.
3. **Минимальная связанность:** Композиция уменьшает сильную зависимость между структурами.
4. **Прозрачность:** Регистрация полей и методов делает логику понятной и предсказуемой.

### Основные понятия ООП в Go

| **Принцип**      | **Реализация в Go**                                                         |
| ---------------- | --------------------------------------------------------------------------- |
| **Наследование** | Через композицию (вложение структур).                                       |
| **Полиморфизм**  | Через интерфейсы.                                                           |
| **Инкапсуляция** | Через экспортируемые и неэкспортируемые поля и методы (регистр букв).       |
| **Абстракция**   | Через интерфейсы, которые определяют поведение, а не конкретную реализацию. |

### Ограничения ООП в Go

1. Нет классов и явного наследования.
2. Отсутствуют встроенные конструкторы или деструкторы.
3. Нет перегрузки методов и операторов.
4. Полиморфизм ограничивается интерфейсами.

### Когда использовать ООП в Go

1. Если требуется разделение поведения на слои (например, через интерфейсы).
2. Для создания гибких систем, которые могут адаптироваться к изменениям.
3. Для инкапсуляции сложной логики внутри структур.

## Примеры

### 1. Структуры (аналог классов)

Вместо классов в Go используются **структуры** (`struct`). Структура — это набор полей, которые описывают объект.

Пример:

```go
type Cowboy struct {
    Name  string
    Age   int
    Horse string
}

func main() {
    c := Cowboy{Name: "John", Age: 35, Horse: "Mustang"}
    fmt.Println(c.Name) // Вывод: John
}
```

### 2. Методы

Методы в Go позволяют "привязывать" функции к типам, включая структуры.

Пример:

```go
type Cowboy struct {
    Name string
}

// Метод для структуры Cowboy
func (c Cowboy) Greet() {
    fmt.Printf("Howdy, partner! My name is %s.\n", c.Name)
}

func main() {
    c := Cowboy{Name: "John"}
    c.Greet() // Вывод: Howdy, partner! My name is John.
}
```

### 3. Инкапсуляция

В Go инкапсуляция достигается через использование заглавных и строчных букв:

- Поля или методы, начинающиеся с **заглавной буквы**, экспортируются (доступны из других пакетов).
- Поля или методы со **строчной буквы** являются приватными.

Пример:

```go
type Cowboy struct {
    Name  string // Доступно из других пакетов
    horse string // Приватное поле
}

func (c Cowboy) GetHorse() string {
    return c.horse // Доступ через метод
}
```

### 4. Интерфейсы (Полиморфизм)

Интерфейсы определяют набор методов, которые должен реализовать тип, чтобы соответствовать этому интерфейсу.

Пример:

```go
type Rider interface {
    Ride() string
}

type Cowboy struct {
    Name string
}

func (c Cowboy) Ride() string {
    return fmt.Sprintf("%s is riding a horse!", c.Name)
}

func main() {
    var rider Rider = Cowboy{Name: "John"}
    fmt.Println(rider.Ride()) // Вывод: John is riding a horse!
}
```

Go позволяет использовать интерфейсы для достижения полиморфизма. Например, разные типы могут реализовывать один и тот же интерфейс.

### 5. Композиция вместо наследования

В Go нет наследования, но можно использовать **композицию**, чтобы "встраивать" одну структуру в другую.

Пример:

```go
type Animal struct {
    Legs int
}

type Cowboy struct {
    Name string
    Animal // Встраивание структуры
}

func main() {
    c := Cowboy{Name: "John", Animal: Animal{Legs: 2}}
    fmt.Println(c.Legs) // Вывод: 2
}
```

### 6. Интерфейсы пустого типа

В Go существует специальный интерфейс `interface{}`, который позволяет работать с любыми типами.

Пример:

```go
func Describe(i interface{}) {
    fmt.Printf("Type: %T, Value: %v\n", i, i)
}

func main() {
    Describe("Howdy")  // Type: string, Value: Howdy
    Describe(42)       // Type: int, Value: 42
    Describe(true)     // Type: bool, Value: true
}
```

### 7. Duck Typing

Go поддерживает "утиное типизирование": если тип реализует методы интерфейса, он соответствует этому интерфейсу, даже если явно это не указано.

Пример:

```go
type Rider interface {
    Ride() string
}

type Cowboy struct {
    Name string
}

func (c Cowboy) Ride() string {
    return fmt.Sprintf("%s is riding!", c.Name)
}

func TestRide(r Rider) {
    fmt.Println(r.Ride())
}

func main() {
    c := Cowboy{Name: "John"}
    TestRide(c) // Вывод: John is riding!
}
```
