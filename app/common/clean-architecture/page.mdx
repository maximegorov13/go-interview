# Clean Architecture

Пример проекта: [GitHub go-clean-template](https://github.com/evrone/go-clean-template)

## Цель Чистой Архитектуры:

1. Изолировать бизнес-логику: Сделать ядро приложения (его суть, правила, процессы) независимым от конкретных фреймворков, баз данных, внешних сервисов или UI. Это позволяет легко заменять внешние зависимости без переписывания бизнес-логики.
2. Обеспечить тестируемость: Бизнес-логика должна легко тестироваться изолированно от внешнего мира.
3. Обеспечить гибкость и поддерживаемость: Упростить понимание, изменение и расширение приложения, особенно при его росте.

## Основные Принципы

1. Зависимости направлены внутрь: Модули внешних слоёв зависят от модулей внутренних слоёв, но не наоборот. Внутренние слои ничего не знают о внешних.
2. Использование интерфейсов: Внутренние слои определяют интерфейсы, которые должны реализовываться внешними слоем. Это позволяет внутреннему слою "работать" с внешним, не зная его конкретной реализации.
3. Слои: Приложение делится на слои, каждый из которых имеет свою ответственность.

## Слои

Шаблон делит приложение на два основных слоя:

### 1. Внутренний Слой (Ядро)

**Содержит**:

- Сущности (`internal/entity`): Это основные структуры данных, представляющие бизнес-объекты (например, `User`, `Order`, `Product`). Они содержат бизнес-логику, связанную с самим объектом (например, методы валидации).
- Бизнес-логика (`internal/usecase`): Это сердце приложения. Здесь происходят "сценарии использования". Этот слой содержит логику, как данные обрабатываются, какие правила применяются, какие действия должны быть выполнены. Он не зависит от конкретных баз данных, веб-фреймворков или внешних API.

**Характеристики**:

- Использует только стандартную библиотеку Go.
- Не импортирует пакеты из внешнего слоя (например, `internal/controller`, `internal/infrastructure`, `pkg/database`, `github.com/some-framework`).
- Общается с внешним миром только через интерфейсы, которые он сам определяет.
- Это чистый Go-код, независимый от инфраструктуры.

### 2. Внешний Слой (Инфраструктура / Адаптеры)

**Содержит**:

- Контроллеры / Обработчики (`internal/controller`): Отвечают за прием запросов от внешнего мира (HTTP, gRPC, AMQP RPC) и передачу данных в бизнес-логику. Также формируют ответы.
- Репозитории (`internal/usecase/repo`): Реализуют интерфейсы, определенные в `usecase`. Обеспечивают доступ к базе данных или другому источнику данных.
- Веб-API (`internal/usecase/webapi`): Реализуют интерфейсы, определенные в `usecase`. Обеспечивают вызовы других внешних API.
- Конфигурация, Логгеры, Метрики и т.д.: Все, что связано с инфраструктурой.

**Характеристики**:

- Зависит от внешних пакетов (базы данных, веб-фреймворки, HTTP-клиенты и т.п.).
- Реализует интерфейсы, определенные во внутреннем слое.
- Преобразует данные из/в формат, удобный для внутреннего слоя (`internal/entity`).
- Компоненты внешнего слоя не должны знать друг о друге. Например, HTTP-обработчик не должен напрямую использовать `sql.DB`. Взаимодействие между ними происходит через внутренний слой (бизнес-логику).

#### Как это работает (на примере HTTP)

1. Приходит HTTP-запрос (например, POST `/users`).
2. Контроллер (`internal/controller/http`) получает запрос, парсит его.
3. Контроллер вызывает метод бизнес-логики (`usecase`), передавая ему данные (например, `userCreateRequest`), преобразованные в формат `internal/entity`.
4. Бизнес-логика (`internal/usecase`) получает данные. Она не знает, что запрос пришёл по HTTP. Она просто получила структуру `entity.User`.
5. Бизнес-логика выполняет свою работу (валидация, применение правил и т.д.).
6. Если нужно сохранить пользователя, бизнес-логика вызывает метод интерфейса, который ей был внедрён (Dependency Injection). Например, `uc.userRepo.Create(user)`.
7. Этот интерфейс реализуется репозиторием (`internal/usecase/repo`). Репозиторий знает, как работать с конкретной БД (например, используя `pgx`).
8. Репозиторий выполняет SQL-запрос и возвращает результат бизнес-логике.
9. Бизнес-логика возвращает результат (нового пользователя или ошибку) контроллеру.
10. Контроллер формирует HTTP-ответ (например, `201 Created` с JSON-ом нового пользователя).
11. Ответ отправляется клиенту.

**Важно**: Контроллер знает о бизнес-логике (он её вызывает). Бизнес-логика знает об интерфейсе репозитория (он вызывает его методы). Но бизнес-логика не знает о конкретной реализации репозитория (о `pgx`). Репозиторий не знает о контроллере. Зависимости направлены внутрь.

### 3. Внедрение Зависимостей (Dependency Injection)

- Используется для передачи реализаций интерфейсов из внешнего слоя во внутренний.
- Обычно реализуется через конструкторы `New(...)`. Например, `NewUserUseCase(repo UserRepository) *UserUseCase`.
- Это позволяет бизнес-логике работать с абстракциями и легко подставлять разные реализации (например, для тестов).

## Версии API

Шаблон показывает, как просто можно организовать версионирование для разных типов серверов (REST, gRPC, AMQP RPC), создавая отдельные папки для каждой версии (например, `http/v1`, `http/v2`).

## Преимущества

- **Тестируемость**: Можно легко подставлять моки репозиториев/веб-API при тестировании бизнес-логики.
- **Гибкость**: Легко заменить базу данных, веб-фреймворк или внешний API, просто изменив реализацию соответствующего интерфейса.
- **Поддерживаемость**: Ясно, где что находится. Бизнес-логика изолирована.
- **Портативность**: Ядро приложения может быть переиспользовано в другом проекте с другой инфраструктурой.

## Сравнение

- Оригинальная Чистая Архитектура (Роберт Мартин): Имеет 4 слоя (Entity, Use Case, Interface Adapters, Frameworks & Drivers). Шаблон `go-clean-template` объединяет некоторые из них (Use Case и Interface Adapters в `usecase`, Frameworks & Drivers в `controller` и `repo/webapi`).
- `Hexagonal (Ports and Adapters)`: Очень похожа. "Ports" - это интерфейсы, "Adapters" - их реализации. Центр - бизнес-логика.
- `Onion Architecture`: Также основана на инверсии зависимостей, схожа с Чистой Архитектурой.

В целом, `go-clean-template` демонстрирует, как применить ключевые идеи Чистой Архитектуры в Go-приложении, разделяя бизнес-логику от инфраструктуры с помощью интерфейсов и внедрения зависимостей.
