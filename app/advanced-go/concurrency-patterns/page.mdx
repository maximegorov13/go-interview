# Паттерны конкурентности

## Future/Promise

Для запуска долгой операции в фоне, чтобы не блокировать основной поток, и получения результата позже.

Мы создаем Future, который содержит канал результата. Фоновая горутина выполняет работу и кладет результат/ошибку, а Await извлекает его, когда он нужен.

```go showLineNumbers filename="main.go"
package main

import (
	"errors"
	"fmt"
	"time"
)

type Result struct {
	Value int
	Err   error
}

type Future struct {
	result chan Result
}

// Пример: Future/Promise.
// Идея: запускаем вычисление в фоне и получаем результат позже.
func AsyncSquare(n int) Future {
	f := Future{result: make(chan Result, 1)}
	go func() {
		defer close(f.result)
		time.Sleep(40 * time.Millisecond)
		if n < 0 {
			f.result <- Result{Err: errors.New("negative input")}
			return
		}
		f.result <- Result{Value: n * n}
	}()
	return f
}

func (f Future) Await() Result {
	return <-f.result
}

func main() {
	future := AsyncSquare(7)

	// Пока результат готовится, можно делать другую работу.
	fmt.Println("doing other work")
	res := future.Await()

	if res.Err != nil {
		fmt.Println("error:", res.Err)
		return
	}
	fmt.Println("result:", res.Value)
}
```

## Generator

Для создания потока данных по мере потребления, без хранения всего набора в памяти.

Генератор запускается в горутине и отправляет значения в канал, закрывая его по завершении.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
)

// Пример: Generator.
// Идея: горутина генерирует поток данных и пишет его в канал.
func generator(from, to int) <-chan int {
	out := make(chan int)
	go func() {
		for i := from; i <= to; i++ {
			out <- i
		}
		close(out)
	}()
	return out
}

func main() {
	for v := range generator(1, 5) {
		fmt.Println("got", v)
	}
}
```

## Pipeline

Для разбиения обработки на этапы и параллельной обработки разных элементов на разных стадиях.

Каждая стадия читает из входного канала и пишет в выходной, формируя конвейер.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
)

// Пример: Pipeline.
// Идея: каждая стадия читает из входного канала и пишет в выходной.
func gen(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		for _, n := range nums {
			out <- n
		}
		close(out)
	}()
	return out
}

func square(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		for n := range in {
			out <- n * n
		}
		close(out)
	}()
	return out
}

func sum(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		total := 0
		for n := range in {
			total += n
		}
		out <- total
		close(out)
	}()
	return out
}

func main() {
	stream := gen(1, 2, 3, 4)
	squares := square(stream)
	total := sum(squares)

	fmt.Println(<-total)
}
```

## Fan-In / Fan-Out

Fan-out распараллеливает работу, fan-in собирает результаты обратно в один поток.

Мы распределяем вход по нескольким воркерам (fan-out), затем объединяем их выходы (fan-in).

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
)

// Пример: Fan-out + Fan-in.
// Идея: fan-out распределяет работу по нескольким воркерам, fan-in собирает результат.
func generator(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		for _, n := range nums {
			out <- n
		}
		close(out)
	}()
	return out
}

func fanOut(in <-chan int, workers int) []<-chan int {
	outs := make([]<-chan int, 0, workers)
	for i := 0; i < workers; i++ {
		out := make(chan int)
		outs = append(outs, out)
		go func(ch chan int) {
			for n := range in {
				ch <- n * n
			}
			close(ch)
		}(out)
	}
	return outs
}

func fanIn(chans ...<-chan int) <-chan int {
	out := make(chan int)
	var wg sync.WaitGroup

	wg.Add(len(chans))
	for _, ch := range chans {
		go func(c <-chan int) {
			defer wg.Done()
			for v := range c {
				out <- v
			}
		}(ch)
	}

	go func() {
		wg.Wait()
		close(out)
	}()

	return out
}

func main() {
	source := generator(1, 2, 3, 4, 5)
	workers := fanOut(source, 3)
	merged := fanIn(workers...)

	for v := range merged {
		fmt.Println(v)
	}
}
```

## Semaphore

Для ограничения числа одновременно выполняемых задач, чтобы не перегружать CPU/IO.

Используем буферизированный канал как счетчик: захват ресурса — запись, освобождение — чтение.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
	"time"
)

// Пример: Semaphore через buffered channel.
// Идея: буфер канала задает максимальное число одновременных задач.
func main() {
	const maxConcurrent = 2
	sem := make(chan struct{}, maxConcurrent)

	var wg sync.WaitGroup
	for i := 1; i <= 5; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			sem <- struct{}{}
			fmt.Printf("start %d\n", id)
			time.Sleep(50 * time.Millisecond)
			fmt.Printf("end %d\n", id)
			<-sem
		}(i)
	}

	wg.Wait()
}
```

## Worker Pool

Для обработки большого количества задач ограниченным числом воркеров.

Есть общий канал задач, из которого читают несколько горутин-воркеров.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
	"time"
)

type Job struct {
	ID      int
	Payload int
}

type Result struct {
	JobID    int
	WorkerID int
	Value    int
}

// Пример: Worker Pool.
// Идея: несколько рабочих горутин читают из общего канала задач.
func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
	defer wg.Done()
	for job := range jobs {
		time.Sleep(30 * time.Millisecond)
		results <- Result{
			JobID:    job.ID,
			WorkerID: id,
			Value:    job.Payload * job.Payload,
		}
	}
}

func main() {
	const workerCount = 3
	const jobCount = 8

	jobs := make(chan Job)
	results := make(chan Result)

	var wg sync.WaitGroup
	wg.Add(workerCount)
	for i := 0; i < workerCount; i++ {
		go worker(i+1, jobs, results, &wg)
	}

	go func() {
		for i := 0; i < jobCount; i++ {
			jobs <- Job{ID: i + 1, Payload: i + 2}
		}
		close(jobs)
	}()

	go func() {
		wg.Wait()
		close(results)
	}()

	for res := range results {
		fmt.Printf("job=%d worker=%d value=%d\n", res.JobID, res.WorkerID, res.Value)
	}
}
```

## Обработка ошибок в горутинах

Для безопасной передачи ошибок из горутин, которые не могут возвращать значение напрямую.

Ошибки отправляются в отдельный канал и централизованно обрабатываются.

```go showLineNumbers filename="main.go"
package main

import (
	"errors"
	"fmt"
	"sync"
)

// Пример: обработка ошибок в горутинах через канал.
// Идея: горутины не могут возвращать ошибку напрямую, поэтому шлем ее в errCh.
func worker(id int, in <-chan int, errCh chan<- error, wg *sync.WaitGroup) {
	defer wg.Done()
	for n := range in {
		if n < 0 {
			errCh <- fmt.Errorf("worker %d: %w", id, errors.New("negative input"))
			return
		}
		_ = n * n
	}
}

func main() {
	inputs := []int{2, 4, -1, 3}
	jobs := make(chan int)
	errCh := make(chan error, 2)

	var wg sync.WaitGroup
	for i := 1; i <= 2; i++ {
		wg.Add(1)
		go worker(i, jobs, errCh, &wg)
	}

	go func() {
		for _, v := range inputs {
			jobs <- v
		}
		close(jobs)
	}()

	go func() {
		wg.Wait()
		close(errCh)
	}()

	for err := range errCh {
		fmt.Println("error:", err)
	}
}
```

## WaitGroup

Для ожидания завершения набора горутин перед продолжением работы.

Каждая горутина делает Done, а главный поток вызывает Wait.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
)

// Пример: WaitGroup.
// Идея: запускаем несколько задач параллельно и ждем завершения всех.
func main() {
	var wg sync.WaitGroup

	for i := 1; i <= 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			fmt.Printf("task %d done\n", id)
		}(i)
	}

	wg.Wait()
	fmt.Println("all tasks completed")
}
```

## Закрытие канала после wg.Wait()

Для безопасного закрытия канала после завершения всех отправителей.

Отдельная горутина ждет wg.Wait() и затем закрывает канал результатов.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
)

// Пример: закрытие канала после завершения всех отправителей.
func main() {
	out := make(chan int)
	var wg sync.WaitGroup

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			out <- id
		}(i)
	}

	go func() {
		wg.Wait()
		close(out)
	}()

	for v := range out {
		fmt.Println(v)
	}
}
```

## Producer / Consumer

Для разделения производства и потребления данных с буферизацией и асинхронной обработкой.

Производитель пишет в канал, потребитель читает и обрабатывает.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: producer-consumer через канал.
// Идея: производитель отправляет задачи, потребитель обрабатывает по мере поступления.
func producer(out chan<- int) {
	defer close(out)
	for i := 1; i <= 5; i++ {
		out <- i
	}
}

func consumer(in <-chan int) {
	for v := range in {
		time.Sleep(20 * time.Millisecond)
		fmt.Println("processed", v)
	}
}

func main() {
	jobs := make(chan int)

	go producer(jobs)
	consumer(jobs)
}
```

## Небуферизованный канал

Для синхронизации отправителя и получателя «встречной» передачей.

Отправка блокируется, пока не появится получатель, и наоборот.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: unbuffered channel синхронизирует отправителя и получателя.
// Идея: отправка и получение блокируются до встречи.
func main() {
	ch := make(chan int)

	go func() {
		fmt.Println("sending")
		ch <- 10
		fmt.Println("sent")
	}()

	time.Sleep(30 * time.Millisecond)
	fmt.Println("receiving")
	v := <-ch
	fmt.Println("got", v)
}
```

## Буферизованный канал

Для сглаживания разницы скоростей продюсера и потребителя.

Буфер позволяет временно накапливать значения до заданного размера.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: buffered channel сглаживает пики нагрузки.
// Идея: продюсер пишет быстрее потребителя, буфер принимает часть сообщений.
func main() {
	ch := make(chan int, 3)

	go func() {
		for i := 1; i <= 5; i++ {
			ch <- i
			fmt.Println("sent", i)
		}
		close(ch)
	}()

	for v := range ch {
		fmt.Println("recv", v)
		time.Sleep(25 * time.Millisecond)
	}
}
```

## Закрытие канала

Для сигнала о завершении потока данных потребителям.

Закрытый канал возвращает zero value и ok=false; range завершится.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
)

// Пример: закрытие канала и проверка ok-флага.
// Идея: range и ok сигнализируют о завершении потока.
func main() {
	ch := make(chan int)

	go func() {
		for i := 1; i <= 3; i++ {
			ch <- i
		}
		close(ch)
	}()

	for {
		v, ok := <-ch
		if !ok {
			fmt.Println("channel closed")
			break
		}
		fmt.Println("recv", v)
	}
}
```

## Select (базовый)

Для ожидания нескольких каналов и реакции на тот, который готов первым.

Select выбирает готовую операцию приема/отправки.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: базовый select между несколькими каналами.
// Идея: реагируем на первое готовое событие.
func main() {
	a := make(chan string)
	b := make(chan string)

	go func() {
		time.Sleep(30 * time.Millisecond)
		a <- "from a"
	}()
	go func() {
		time.Sleep(50 * time.Millisecond)
		b <- "from b"
	}()

	for i := 0; i < 2; i++ {
		select {
		case v := <-a:
			fmt.Println(v)
		case v := <-b:
			fmt.Println(v)
		}
	}
}
```

## Select с таймаутом

Для ограничения времени ожидания ответа.

Используем time.After как дополнительный канал.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: select с таймаутом.
// Идея: ограничиваем ожидание результата через time.After.
func main() {
	result := make(chan string)

	go func() {
		time.Sleep(80 * time.Millisecond)
		result <- "done"
	}()

	select {
	case v := <-result:
		fmt.Println("result:", v)
	case <-time.After(40 * time.Millisecond):
		fmt.Println("timeout")
	}
}
```

## Select с default

Для неблокирующей попытки чтения/записи.

Если канал не готов, выполняется default.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: неблокирующий select с default.
// Идея: если канал не готов, выполняем альтернативную ветку.
func main() {
	ch := make(chan int)

	select {
	case v := <-ch:
		fmt.Println("got", v)
	default:
		fmt.Println("no data yet")
	}

	go func() {
		time.Sleep(30 * time.Millisecond)
		ch <- 42
	}()

	time.Sleep(40 * time.Millisecond)
	select {
	case v := <-ch:
		fmt.Println("got", v)
	default:
		fmt.Println("still no data")
	}
}
```

## Select с nil-каналами

Для динамического включения/выключения веток select.

nil-канал никогда не готов, поэтому ветка фактически отключается.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: nil-каналы для отключения веток select.
// Идея: присваиваем nil, чтобы временно исключить канал из select.
func main() {
	a := make(chan int)
	b := make(chan int)

	go func() {
		a <- 1
		close(a)
	}()
	go func() {
		time.Sleep(20 * time.Millisecond)
		b <- 2
		close(b)
	}()

	for a != nil || b != nil {
		select {
		case v, ok := <-a:
			if !ok {
				a = nil
				continue
			}
			fmt.Println("a", v)
		case v, ok := <-b:
			if !ok {
				b = nil
				continue
			}
			fmt.Println("b", v)
		}
	}
}
```

## Mutex

Для защиты разделяемых данных от гонок.

Lock/Unlock оборачивают критическую секцию.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
)

// Пример: mutex для защиты общего счетчика.
// Идея: синхронизируем доступ к разделяемым данным.
func main() {
	var (
		mu      sync.Mutex
		counter int
		wg      sync.WaitGroup
	)

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < 1000; j++ {
				mu.Lock()
				counter++
				mu.Unlock()
			}
		}()
	}

	wg.Wait()
	fmt.Println("counter:", counter)
}
```

## RWMutex

Для оптимизации read-heavy данных: много читателей, редкие записи.

RLock для чтений, Lock для записей.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
	"time"
)

// Пример: RWMutex для разделения чтений и записей.
// Идея: много читателей, редкие записи.
func main() {
	var (
		mu sync.RWMutex
		v  int
		wg sync.WaitGroup
	)

	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i < 3; i++ {
			mu.Lock()
			v++
			mu.Unlock()
			time.Sleep(30 * time.Millisecond)
		}
	}()

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			mu.RLock()
			fmt.Printf("reader %d sees %d\n", id, v)
			mu.RUnlock()
		}(i + 1)
	}

	wg.Wait()
}
```

## Atomic

Для простых атомарных операций без mutex.

atomic.AddInt64/Load/Store обеспечивают безопасность на уровне CPU.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

// Пример: atomic для счетчика без mutex.
// Идея: безопасные инкременты через atomic.AddInt64.
func main() {
	var (
		counter int64
		wg      sync.WaitGroup
	)

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < 1000; j++ {
				atomic.AddInt64(&counter, 1)
			}
		}()
	}

	wg.Wait()
	fmt.Println("counter:", counter)
}
```

## sync.Once

Для гарантии однократной инициализации в конкурентной среде.

Do выполнит функцию ровно один раз.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
)

// Пример: sync.Once для однократной инициализации.
// Идея: код внутри Do выполнится ровно один раз.
func main() {
	var (
		once sync.Once
		wg   sync.WaitGroup
	)

	init := func() {
		fmt.Println("initialized")
	}

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			once.Do(init)
		}()
	}

	wg.Wait()
}
```

## sync.Cond

Для ожидания состояния, которое изменяется другим потоком.

Wait блокирует до Signal/Broadcast при удержании mutex.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
	"time"
)

// Пример: sync.Cond для ожидания условия.
// Идея: потребитель ждет, пока очередь не станет непустой.
func main() {
	mu := sync.Mutex{}
	cond := sync.NewCond(&mu)
	queue := make([]int, 0)
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		mu.Lock()
		for len(queue) == 0 {
			cond.Wait()
		}
		item := queue[0]
		queue = queue[1:]
		mu.Unlock()
		fmt.Println("got", item)
	}()

	time.Sleep(30 * time.Millisecond)
	mu.Lock()
	queue = append(queue, 42)
	cond.Signal()
	mu.Unlock()

	wg.Wait()
}
```

## Done-канал

Для кооперативного завершения горутин.

Закрытие done сигнализирует всем слушателям выйти.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: done-канал для остановки горутины.
// Идея: закрытие done сигнализирует всем слушателям завершиться.
func worker(done <-chan struct{}, out chan<- int) {
	defer close(out)
	for i := 1; ; i++ {
		select {
		case <-done:
			return
		case out <- i:
			time.Sleep(15 * time.Millisecond)
		}
	}
}

func main() {
	done := make(chan struct{})
	out := make(chan int)

	go worker(done, out)

	for v := range out {
		fmt.Println(v)
		if v == 5 {
			close(done)
		}
	}
}
```

## Context cancel

Для отмены работы и передачи сигнала отмены по всей цепочке вызовов.

WithCancel создает ctx, cancel вызывает Done у всех потребителей.

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"time"
)

// Пример: отмена работы через context.
// Идея: передаем ctx в горутину и завершаем ее при cancel().
func worker(ctx context.Context, out chan<- int) {
	defer close(out)
	for i := 1; ; i++ {
		select {
		case <-ctx.Done():
			return
		case out <- i:
			time.Sleep(20 * time.Millisecond)
		}
	}
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	out := make(chan int)
	go worker(ctx, out)

	for v := range out {
		fmt.Println(v)
		if v == 5 {
			cancel()
		}
	}
}
```

## Context timeout

Для автоматической отмены по таймауту.

WithTimeout завершает контекст по истечении времени.

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"time"
)

// Пример: context.WithTimeout для ограничения времени работы.
// Идея: прекращаем работу, если дедлайн истек.
func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
	defer cancel()

	work := make(chan string)
	go func() {
		time.Sleep(80 * time.Millisecond)
		work <- "done"
	}()

	select {
	case v := <-work:
		fmt.Println("result:", v)
	case <-ctx.Done():
		fmt.Println("timeout:", ctx.Err())
	}
}
```

## Context tree cancel

Для каскадной отмены дочерних задач.

Отмена родителя отменяет все дочерние контексты.

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

// Пример: дерево контекстов и каскадная отмена.
// Идея: отмена родителя завершает всех потомков.
func worker(ctx context.Context, id int, wg *sync.WaitGroup) {
	defer wg.Done()
	for {
		select {
		case <-ctx.Done():
			fmt.Println("stop", id)
			return
		default:
			time.Sleep(15 * time.Millisecond)
		}
	}
}

func main() {
	root, cancelRoot := context.WithCancel(context.Background())
	child, cancelChild := context.WithCancel(root)
	defer cancelChild()

	var wg sync.WaitGroup
	wg.Add(2)
	go worker(root, 1, &wg)
	go worker(child, 2, &wg)

	time.Sleep(40 * time.Millisecond)
	cancelRoot()

	wg.Wait()
}
```

## Общий дедлайн для группы задач

Для ограничения времени целой группы и сбора ошибок.

Все задачи слушают ctx.Done(), ошибки собираются в общий канал.

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
)

// Пример: общий дедлайн для группы задач + сбор ошибок.
// Идея: задачи слушают ctx.Done(), ошибки собираются в канал.
func task(ctx context.Context, id int, errCh chan<- error, wg *sync.WaitGroup) {
	defer wg.Done()
	select {
	case <-ctx.Done():
		return
	case <-time.After(time.Duration(20+id*10) * time.Millisecond):
		if id == 2 {
			errCh <- errors.New("task 2 failed")
		}
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
	defer cancel()

	errCh := make(chan error, 3)
	var wg sync.WaitGroup

	for i := 1; i <= 3; i++ {
		wg.Add(1)
		go task(ctx, i, errCh, &wg)
	}

	go func() {
		wg.Wait()
		close(errCh)
	}()

	for err := range errCh {
		fmt.Println("error:", err)
	}
}
```

## errgroup

Для запуска группы задач с общей отменой при первой ошибке.

errgroup.WithContext отменяет контекст при любой ошибке.

```go showLineNumbers filename="main.go"
package main

import (
	"context"
	"errors"
	"fmt"
	"time"

	"golang.org/x/sync/errgroup"
)

// Пример: errgroup для запуска задач с общей отменой при ошибке.
// Идея: первая ошибка отменяет контекст всей группы.
func main() {
	ctx := context.Background()
	g, ctx := errgroup.WithContext(ctx)

	g.Go(func() error {
		time.Sleep(20 * time.Millisecond)
		return nil
	})

	g.Go(func() error {
		time.Sleep(30 * time.Millisecond)
		return errors.New("boom")
	})

	g.Go(func() error {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(80 * time.Millisecond):
			return nil
		}
	})

	if err := g.Wait(); err != nil {
		fmt.Println("error:", err)
	}
}
```

## Rate limiting

Для ограничения частоты обработки событий.

Ticker задает минимальный интервал между обработками.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: rate limiting через time.Ticker.
// Идея: обрабатываем элементы не чаще заданного интервала.
func main() {
	inputs := []string{"a", "b", "c", "d", "e"}
	ticker := time.NewTicker(40 * time.Millisecond)
	defer ticker.Stop()

	for _, v := range inputs {
		<-ticker.C
		fmt.Println("processed", v)
	}
}
```

## Heartbeat

Для контроля «живости» воркера и обнаружения зависаний.

Воркер периодически шлет сигнал в heartbeat канал.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"time"
)

// Пример: heartbeat-канал для мониторинга активности.
// Идея: воркер периодически шлет сигнал, что жив.
func worker(done <-chan struct{}, heartbeat chan<- struct{}) {
	ticker := time.NewTicker(20 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-done:
			return
		case <-ticker.C:
			heartbeat <- struct{}{}
		}
	}
}

func main() {
	done := make(chan struct{})
	heartbeat := make(chan struct{}, 1)

	go worker(done, heartbeat)

	timeout := time.NewTimer(70 * time.Millisecond)
	defer timeout.Stop()

	for {
		select {
		case <-heartbeat:
			fmt.Println("alive")
		case <-timeout.C:
			fmt.Println("worker timeout")
			close(done)
			return
		}
	}
}
```

## sync.Map

Для конкурентного доступа к map без ручных блокировок.

Store/Load/Range безопасны при конкурентном доступе.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
)

// Пример: sync.Map для конкурентного доступа без ручных локов.
// Идея: удобно для read-heavy карт.
func main() {
	var m sync.Map

	m.Store("a", 1)
	m.Store("b", 2)

	if v, ok := m.Load("a"); ok {
		fmt.Println("a", v)
	}

	m.Range(func(k, v any) bool {
		fmt.Printf("%v=%v\n", k, v)
		return true
	})
}
```

## sync.Pool

Для переиспользования временных объектов и уменьшения аллокаций.

Get/Put возвращают объекты в пул для повторного использования.

```go showLineNumbers filename="main.go"
package main

import (
	"fmt"
	"sync"
)

// Пример: sync.Pool для переиспользования временных объектов.
// Идея: снижает аллокации в горячих участках.
func main() {
	pool := sync.Pool{
		New: func() any {
			return make([]byte, 0, 16)
		},
	}

	buf := pool.Get().([]byte)
	buf = append(buf, 'h', 'i')
	fmt.Println(string(buf))

	buf = buf[:0]
	pool.Put(buf)
}
```
