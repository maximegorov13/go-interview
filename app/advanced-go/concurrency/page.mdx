# Concurrency

## Горутины

Горутина — это легковесный поток, управляемый планировщиком Go. Она создаётся с помощью ключевого слова `go`, и её стек занимает значительно меньше памяти, чем у традиционного потока. Горутины управляются планировщиком Go (GMP-модель: Goroutines, M-threads, P-processors) и переключаются между потоками автоматически.

**Преимущества горутин над потоками:**

1. Меньший размер стека (обычно 2–4 КБ).
2. Возможность динамического расширения стека.
3. Планировщик Go позволяет эффективно управлять тысячами горутин.

## Каналы

Каналы — это примитив синхронизации и связи между горутинами, обеспечивающий потокобезопасный обмен данными. Они создаются с помощью функции `make(chan Type)`.

**Основные свойства:**

1. Каналы могут быть **буферизованными** (с фиксированной ёмкостью) или **небуферизованными**.
2. Операции записи и чтения в каналы являются **блокирующими**:
   - Запись блокируется, пока кто-то не считает данные.
   - Чтение блокируется, пока кто-то не запишет данные.

**Аксиомы каналов:**

- **При записи в закрытый канал** — возникает паника.
- **При чтении из закрытого канала** — возвращается нулевое значение и флаг.
- **Нулевой канал (`nil`)**: операции записи/чтения приводят к дедлоку.

**Поведение каналов:**

| Операция         | Канал без буфера                           | Канал с буфером                           | Закрытый канал                                | Нулевой канал     |
|------------------|--------------------------------------------|-------------------------------------------|---------------------------------------------|-----------------|
| Отправка значения | Отправляет, если получатель доступен, иначе **блокируется** | Отправляет, если есть место, иначе **блокируется** | **Паника**                                  | **Блокировка**  |
| Получение значения | Получает, если данные доступны, иначе **блокируется** | Получает, если данные доступны, иначе **блокируется** | Получает оставшиеся или нулевое значение, если пусто | **Блокировка**  |
| Закрытие         | ✅                                         | ✅                                        | **Паника**                                  | **Паника**      |


## Мьютексы

`sync.Mutex` — это примитив синхронизации, который обеспечивает взаимное исключение при доступе к разделяемым данным.

**Основные методы:**

1. `Lock()`: блокирует доступ к критической секции.
2. `Unlock()`: освобождает блокировку.

## Атомики

Пакет `sync/atomic` предоставляет низкоуровневые операции, такие как атомарное увеличение счётчиков и обмен значениями. Это позволяет избежать гонок данных без использования мьютексов.

**Основные свойства атомиков:**

1. Атомарные операции выполняются за одно машинное командное слово, что исключает возможность гонок данных.
2. Используются для простых счётчиков, флагов и других переменных состояния.

**Примеры атомиков:**

- `atomic.AddInt32(&counter, 1)`: атомарное увеличение счётчика.
- `atomic.LoadInt32(&counter)`: безопасное чтение значения.

## Select

`select` — это конструкция для работы с несколькими каналами одновременно. Она позволяет ожидать данные или события от нескольких источников, выполняя соответствующую операцию, как только канал становится доступным.

**Основные свойства:**

1. **Асинхронная обработка каналов**: позволяет обрабатывать данные без блокировки основной программы.
2. **Мультиплексирование**: ожидание событий от нескольких каналов одновременно.
3. **Поддержка таймаутов**: позволяет завершать операции, если данные не поступили за заданное время.

**Синтаксис:**

```go showLineNumbers filename="main.go"
select {
case val := <-channel1:
    fmt.Println("Получены данные из channel1:", val)
case channel2 <- value:
    fmt.Println("Отправлены данные в channel2")
default:
    fmt.Println("Нет готовых каналов, выполняется default")
}
```

**Применение `select`:**

1. **Ожидание данных от нескольких каналов.**
2. **Обработка таймаутов с помощью `time.After`.**
3. **Асинхронная запись и чтение.**

## Sync

`sync` — это стандартная библиотека Go, которая предоставляет примитивы для синхронизации данных между горутинами.

**Основные элементы `sync`:**

1. **Мьютексы (Mutex):**
   - Используются для блокировки доступа к разделяемым данным.
   - `sync.Mutex` и `sync.RWMutex` для чтения и записи.

2. **WaitGroup:**
   - Помогает синхронизировать выполнение нескольких горутин.
   - Устанавливает "счётчик" для ожидания завершения всех задач.

3. **Once:**
   - Обеспечивает выполнение кода только один раз в многопоточной среде.

4. **Pool:**
   - Позволяет переиспользовать объекты, чтобы снизить нагрузку на сборщик мусора.

**Неблокирующие алгоритмы:**

- Использование `atomic` вместо `Mutex` для простых операций.
- Каналы для синхронизации без явной блокировки.

## Ключевые вопросы

### 1. Как каналы устроены в Go?

Каналы в Go реализованы как кольцевые буферы с поддержкой блокирующих операций. Каждый канал управляется мьютексами для обеспечения потокобезопасности. Они позволяют передавать данные между горутинами и синхронизировать их выполнение.

### 2. Какие типы каналов существуют?

1. **Буферизованные каналы**: имеют фиксированную ёмкость; запись не блокируется, пока буфер не заполнен.
2. **Небуферизованные каналы**: запись блокируется до тех пор, пока другой процесс не считает данные.
3. **Однонаправленные каналы**: предназначены только для записи (`chan<-`) или только для чтения (`<-chan`).

### 3. Что будет, если попытаться писать в закрытый канал?

Возникнет **паника** (`panic: send on closed channel`).

### 4. В чём разница между буферизованными и небуферизованными каналами?

- **Буферизованный канал** позволяет временно хранить данные в буфере. Запись блокируется только при заполнении буфера.
- **Небуферизованный канал** требует немедленного чтения записанных данных; запись блокируется, пока данные не будут считаны.

### 5. Через какой канал возможна проверка работы горутины?

Можно использовать **канал done** или **контекст с таймаутом** для отслеживания завершения работы горутины.

### 6. Как закрыть канал?

Канал закрывается функцией `close(channel)`. Только **отправитель** должен закрывать канал.

### 7. Какие действия можно производить с каналами?

1. **Запись**: `channel <- value`.
2. **Чтение**: `value := <-channel`.
3. **Закрытие**: `close(channel)`.
4. **Перебор**: `for value := range channel`.

### 8. Какие последствия чтения из закрытого канала?

- Возвращается **нулевое значение** типа канала.
- Флаг успешности (`ok`) становится **false**.

### 9. Что такое nil-канал и что будет, если писать и читать из него?

`nil`-канал — это неинициализированный канал. Любая операция записи или чтения приведёт к **дедлоку**.

### 10. Что можно и что нельзя делать с потокобезопасностью каналов?

- **Можно:** использовать каналы для синхронизации данных между горутинами.
- **Нельзя:** использовать каналы для высокоскоростного обмена данными без учёта их производительности.

### 11. Что будет, если закрыть закрытый канал?

Возникнет **паника** (`panic: close of closed channel`).

### 12. Насколько безопасны каналы?

Каналы потокобезопасны, так как используют мьютексы для управления доступом. Однако при неправильном использовании (например, конкурентное закрытие или работа с nil-каналом) могут возникнуть ошибки.

### 13. Что можно делать с закрытым каналом?

1. Читать данные, если они ещё есть в буфере.
2. Перебирать оставшиеся элементы с помощью `for range`.

### 14. Что делать, если канал int и был получен ноль?

Использовать второй флаг (`ok`), возвращаемый при чтении из канала:

```go showLineNumbers filename="main.go"
value, ok := <-channel
if !ok {
    // Канал закрыт
}
```

## Практические аспекты с памятью

### 1. Процессор и взаимодействие с программой

Go компилируется в машинный код, который исполняется процессором.

Процессор работает последовательно, выполняя инструкции, скомпилированные из абстракций Go, таких как структуры, функции, указатели и горутины.

### 2. Размещение памяти: Стек и Куча

**Стек (Stack)**

- **Размер:** ограничен 1 МБ (можно изменить флагами компилятора).
- **Особенности:**
  - Работает по принципу LIFO (Last In, First Out).
  - Быстрый доступ, так как память выделяется блоками.
  - Используется для хранения локальных переменных, аргументов функций, временных данных.
  - У каждой горутины свой собственный стек, управляемый рантаймом.

**Куча (Heap)**

- **Размер:** динамический, ограничен доступной памятью.
- **Особенности:**
  - Используется для хранения динамически выделенных данных: объектов, слайсов, мап, строк, каналов.
  - Память управляется сборщиком мусора (GC).
  - Доступ медленнее, чем к стеку, так как переменные хранятся не в непрерывной области памяти.

### 3. Escape Analysis (анализ утечек)

- Это процесс оптимизации компилятора Go, определяющий, где должна выделяться переменная (в стеке или куче).
- Переменные, доступные только внутри функции, размещаются в стеке.
- Если переменная "убегает" за пределы функции (например, передаётся указатель), она размещается в куче.

### 4. Основные аспекты горутин

**Особенности горутин:**

- Лёгкие, занимают меньше памяти, чем системные потоки (обычно 2–4 КБ).
- Управляются планировщиком Go.
- Не связаны с конкретным системным потоком.
- Используют каналы для безопасной передачи данных.

### 5. Основные аспекты каналов

**Типы каналов:**

1. **Буферизованные:** записи не блокируются, пока буфер не заполнен.
2. **Небуферизованные:** запись блокируется до чтения.

**Блокировки:**

- Запись в канал блокируется, если буфер заполнен или при чтении данных из небуферизованного канала.
- Планировщик автоматически разблокирует горутины, чтобы избежать дедлоков.

**Аксиомы каналов:**

1. **Запись в закрытый канал:** вызывает панику.
2. **Чтение из закрытого канала:** возвращает нулевое значение и флаг `false`.
3. **Нулевой канал:** операции записи/чтения приводят к дедлоку.

### 6. Как избежать утечки горутин?

- Используйте **контексты с таймаутами** (`context.WithTimeout` или `context.WithCancel`).
- Закрывайте каналы.
- Следите за завершением горутин.

### 7. Что делать при конкурентной записи в мапу?

- Используйте **мьютексы (`sync.Mutex`)** или **каналы**.
- Для безопасного доступа применяйте **`sync.Map`**.

### 8. Как определить проблемы с памятью?

**1. Инструменты профилирования:**

- **`pprof`**: анализ производительности программы.
- **`runtime.MemStats`**: сбор метрик о состоянии памяти.

**2. Распространённые проблемы:**

- **Утечка памяти:** возникает, если программа удерживает ссылки на ненужные объекты.
- **Переполнение стека:** при слишком глубокой рекурсии.

### 9. В чём разница между стеком и кучей?

- **Стек:**
  - Быстрый доступ, выделение фиксированных блоков.
  - Используется для локальных переменных.
- **Куча:**
  - Более гибкий, но медленный доступ.
  - Используется для динамически выделяемых объектов.

### 10. Как узнать, где выделяется переменная?

Используйте профилировщик, например, **`pprof`**, чтобы определить, где размещаются объекты.

### 11. Что быстрее: стек или куча?

**Стек быстрее** из-за работы с непрерывным блоком памяти и автоматического управления.

### 12. Что произойдёт при переполнении стека?

Приведёт к **Stack Overflow**. Это происходит, если стек заполнен, например, из-за глубокой рекурсии.

### 13. Что такое утечка памяти?

Утечка памяти — это ситуация, когда память выделяется, но не освобождается, хотя она больше не используется программой.

### 14. Что происходит при полном заполнении памяти слайсом?

Программа завершится ошибкой `runtime: out of memory`.
