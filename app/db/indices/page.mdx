# Индексы

Индекс — это специальная структура данных, которая создаётся для ускорения поиска и выборки данных в таблицах базы данных. Индексы хранятся отдельно от данных таблицы и позволяют быстрее находить строки, соответствующие условиям запроса.

## Типы индексов

### 1. Простые индексы (Single-Column Index)

- Создаются на один столбец таблицы.
- Ускоряют поиск и фильтрацию данных по этому столбцу.
- Ограничения:
- Если запросы используют несколько столбцов, может потребоваться создание составного индекса.

**Пример использования:**
Поиск записей по идентификатору пользователя (ID).

### 2. Составные индексы (Composite Index)

- Создаются на несколько столбцов таблицы.
- Используются для запросов, которые включают фильтрацию или сортировку по нескольким столбцам.
- Важно: порядок столбцов в составном индексе влияет на его использование. Индекс работает только если запрос использует столбцы слева направо.

**Пример:**

Индекс на столбцы `(region, city)`:

- Подходит для запроса по `region` или по `region` и `city`.
- Не работает для запроса только по `city`.

### 3. B-Tree индексы

**Структура:** Сбалансированное дерево (Binary Tree), где данные организованы по уровням.

**Особенности:**

- Поддерживают сортировку.
- Идеально подходят для поиска по точному значению и диапазонам.
- Используются по умолчанию в большинстве реляционных баз данных.

**Применение:** Запросы с фильтрацией (`WHERE`), сортировкой (`ORDER BY`), выборкой диапазонов (`BETWEEN`).

**Плюсы:**

- Быстрый поиск благодаря логарифмической сложности — `O(log N)`.
- Упорядоченность позволяет работать с диапазонами.

**Минусы:**

- Производительность падает при больших объёмах данных из-за необходимости поддерживать сбалансированное дерево.
- Замедляют операции вставки, обновления и удаления.

### 4. Hash индексы

**Структура:** Основываются на хэш-таблицах.

**Особенности:**

- Предназначены для точного поиска (`=` или `IN`).
- Не поддерживают сортировку или поиск по диапазонам.
- Высокая скорость операций за счёт сложности `O(1)` для поиска.

**Применение:** Часто используются для уникальных ключей и фильтрации по равенству.

**Плюсы:**

- Очень быстрый поиск по точным значениям.
- Компактная структура.

**Минусы:**

- Непригодны для запросов с диапазонами (`<`, `>`, `BETWEEN`).
- Могут вызывать коллизии (два разных значения имеют одинаковый хэш).

### 5. GIN индексы (Generalized Inverted Index)

**Применение:** Для неатомарных структур данных:

- JSON, массивы.
- Полнотекстовый поиск.

**Особенности:**

- Хранит список мест (строк), где встречается каждый элемент данных.
- Ускоряет запросы с операциями на массивы (`@>`, `&&`) и JSON.

**Плюсы:**

- Подходит для работы с большими массивами данных и сложными структурами.
- Оптимизирован для полнотекстового поиска.

**Минусы:**

- Замедляет операции вставки и обновления из-за необходимости обновления индекса.
- Требует больше памяти.

### 6. GIST индексы (Generalized Search Tree)

**Применение:** Для индексирования сложных типов данных:

- Геометрические данные.
- Поиск ближайших соседей.
- Полнотекстовый поиск.

**Особенности:**

- Работают с произвольными функциями сравнения.
- Поддерживают индексацию значений, которые не могут быть упорядочены традиционно.

**Плюсы:**

- Универсальность: можно адаптировать для различных типов данных.
- Подходит для сложных запросов с пользовательскими функциями.

**Минусы:**

- Более сложная структура.
- Замедленные вставки и обновления по сравнению с B-Tree.

### Проблемы и ограничения индексов

1. **Негативное влияние на производительность вставок и обновлений:**

- Каждый раз, когда данные в таблице изменяются, индекс должен быть обновлён.

2. **Использование дискового пространства:**

- Индексы занимают дополнительное место на диске, особенно при использовании сложных структур.

3. **Необходимость анализа запросов:**

- Неправильно созданные индексы могут не использоваться или замедлять выполнение запросов.

4. **Перегрузка избыточными индексами:**

- Слишком большое количество индексов замедляет операции изменения данных.

### Рекомендации по использованию индексов

1. Создавайте индексы для наиболее часто используемых полей в запросах.
2. Используйте составные индексы для сложных фильтров, учитывая порядок столбцов.
3. Оптимизируйте запросы с помощью анализа (`EXPLAIN`), чтобы определить, какие индексы реально используются.
4. Удаляйте неиспользуемые индексы, чтобы избежать избыточности.
5. Регулярно обновляйте статистику базы данных (`ANALYZE`), чтобы индексы работали эффективно.
