# Подзапросы SQL

**Подзапрос**, **внутренний запрос** или **вложенный запрос** — это запрос внутри другого запроса PostgreSQL, встроенный в предложение `WHERE`.

Подзапрос используется для возврата данных, которые будут использоваться в основном запросе в качестве условия для дальнейшего ограничения извлекаемых данных.

Подзапросы могут использоваться с операторами `SELECT`, `INSERT`, `UPDATE` и `DELETE`, вместе с такими операторами, как `=`, `<`, `>`, `>=`, `<=`, `IN` и т. д.

## Правила, которым подзапросы должны подчиняться

- Подзапросы должны быть **заключены в круглые скобки**;
- Подзапрос может иметь **только один столбец** в предложении `SELECT`, если только в основном запросе нет нескольких столбцов для подзапроса для сравнения выбранных столбцов;
- `ORDER BY` не может быть использован в подзапросе, хотя основной запрос может содержать `ORDER BY`. `GROUP BY` может быть использован в подзапросе с той же целью, что и `ORDER BY`;
- Подзапросы, возвращающие более одной строки, могут использоваться только с операторами с несколькими значениями, такими как оператор `IN`, `EXISTS`, `NOT IN`, `ANY/SOME`, `ALL`;
- Оператор `BETWEEN` не может быть использован с подзапросом; хотя, `BETWEEN` можно использовать внутри подзапроса.

## Подзапросы с SELECT

Подзапросы очень часто используются совместно с `SELECT`. Базовый синтаксис выглядит следующим образом:

```sql
SELECT column_name [, column_name ]
FROM   table1 [, table2 ]
WHERE  column_name OPERATOR
      (SELECT column_name [, column_name ]
      FROM table1 [, table2 ]
      [WHERE])
```

**Пример**

Рассмотрим таблицу COMPANY:

| id  | name  | age | address    | salary |
| --- | ----- | --- | ---------- | ------ |
| 1   | Paul  | 32  | California | 20000  |
| 2   | Allen | 25  | Texas      | 15000  |
| 3   | Teddy | 23  | Norway     | 20000  |
| 4   | Mark  | 25  | Rich-Mond  | 65000  |
| 5   | David | 27  | Texas      | 85000  |
| 6   | Kim   | 22  | South-Hall | 45000  |
| 7   | James | 24  | Houston    | 10000  |

Создадим следующий подзапрос с использованием SELECT:

```sql
SELECT *
FROM COMPANY
WHERE ID IN (SELECT ID
   FROM COMPANY
   WHERE SALARY > 45000);
```

Результат будет следующим:

| id  | name  | age | address   | salary |
| --- | ----- | --- | --------- | ------ |
| 4   | Mark  | 25  | Rich-Mond | 65000  |
| 5   | David | 27  | Texas     | 85000  |

## Подзапросы с INSERT

Подзапросы также используются совместно с INSERT. INSERT использует данные из подзапроса для добавления в другую таблицу. Выбранные данные в подзапросе могут быть изменены с использованием символов, дат или нескольких функций.

Базовый синтаксис выглядит следующим способом:

```sql
INSERT INTO table_name [ (column1 [, column2 ]) ]
   SELECT [ *|column1 [, column2 ] ]
   FROM table1 [, table2 ]
   [ WHERE VALUE OPERATOR ]
```

**Пример**

Рассмотрим таблицу COMPANY_BKP, с той же структурой, что и у таблицы COMPANY; она может быть создана при помощи CREATE TABLE, где COMPANY_BKP – название таблицы. Теперь полностью скопируем таблицу COMPANY в COMPANY_BKP, используя следующий синтаксис:

```sql
INSERT INTO COMPANY_BKP
   SELECT * FROM COMPANY
   WHERE ID IN (SELECT ID
      FROM COMPANY);
```

## Подзапросы с использованием UPDATE

Подзапрос также может быть использован совместно с UPDATE. При использовании подзапроса с оператором UPDATE можно обновить один или несколько столбцов в таблице.

Базовый синтаксис:

```sql
UPDATE table
SET column_name = new_value
[ WHERE OPERATOR [ VALUE ]
   (SELECT COLUMN_NAME
   FROM TABLE_NAME)
   [ WHERE) ]
```

**Пример**

Представим, что у нас есть таблица COMPANY_BKP, копия таблицы COMPANY.

Приведенный ниже пример обновит столбец SALARY на 0.50 в таблице COMPANY для всех покупателей, чей возраст больше или равен 27:

```sql
UPDATE COMPANY
   SET SALARY = SALARY * 0.50
   WHERE AGE IN (SELECT AGE FROM COMPANY_BKP
      WHERE AGE >= 27);
```

Данное условие коснется 2 рядов, после чего таблица COMPANY будет иметь следующий вид:

| id  | name  | age | address    | salary |
| --- | ----- | --- | ---------- | ------ |
| 2   | Allen | 25  | Texas      | 15000  |
| 3   | Teddy | 23  | Norway     | 20000  |
| 4   | Mark  | 25  | Rich-Mond  | 65000  |
| 6   | Kim   | 22  | South-Hall | 45000  |
| 7   | James | 24  | Houston    | 10000  |
| 1   | Paul  | 32  | California | 10000  |
| 5   | David | 27  | Texas      | 42500  |

## Подзапросы с использованием DELETE

Подзапрос может быть использован с DELETE по аналогии со всеми другими операторами, указанными выше.

Базовый синтаксис выглядит следующим образом:

```sql
DELETE FROM TABLE_NAME
[ WHERE OPERATOR [ VALUE ]
   (SELECT COLUMN_NAME
   FROM TABLE_NAME)
   [ WHERE) ]
```

**Пример**

Представим, что у нас есть таблица COMPANY_BKP, копия таблицы COMPANY.

Приведенный ниже пример удалит записи из таблицы COMPANY для всех покупателей, чей возраст больше или равен 27:

```sql
DELETE FROM COMPANY
   WHERE AGE IN (SELECT AGE FROM COMPANY_BKP
      WHERE AGE > 27);
```

Данное условие коснется 2 рядов, после чего таблица COMPANY будет иметь следующий вид:

| id  | name  | age | address    | salary |
| --- | ----- | --- | ---------- | ------ |
| 2   | Allen | 25  | Texas      | 15000  |
| 3   | Teddy | 23  | Norway     | 20000  |
| 4   | Mark  | 25  | Rich-Mond  | 65000  |
| 6   | Kim   | 22  | South-Hall | 45000  |
| 7   | James | 24  | Houston    | 10000  |
| 5   | David | 27  | Texas      | 42500  |
