# Error

### **Что такое ошибка в Go?**

- Ошибка в Go — это **интерфейс**, определённый следующим образом:

  ```go showLineNumbers filename="main.go"
  type error interface {
      Error() string
  }
  ```

- Это объект, реализующий метод `Error()`, который возвращает строковое представление ошибки.
- В Go ошибки возвращаются как часть множественных возвращаемых значений функции.

---

### **Обработка ошибок в Go**

1. **Стандартная проверка ошибки:**
   - После вызова функции, возвращающей ошибку, всегда проверяется её значение (`if err != nil`).
   - Если ошибка обнаружена, её можно обработать или вернуть вызывающему коду.

2. **Прокидывание ошибок:**
   - Ошибки, возникающие в одном модуле, можно передавать дальше по цепочке с использованием своей логики.
   - Например, вместо передачи ошибки базы данных можно вернуть пользовательскую ошибку (например, "Объект не найден").

3. **Обёртывание ошибок:**
   - Ошибку можно дополнить дополнительным описанием перед передачей дальше, сохраняя исходную ошибку внутри.
   - Для этого используется `%w` в `fmt.Errorf`.

4. **Сравнение ошибок:**
   - `errors.Is` — проверяет, равна ли ошибка заданной.
   - `errors.As` — проверяет, относится ли ошибка к конкретному типу.

---

### **Классификация ошибок**

1. **Программные ошибки:**
   - Это ошибки, которые можно предусмотреть и обработать.
     Пример: неверный ввод данных, отсутствие файла, сбой соединения.

2. **Критические ошибки (Panic):**
   - Эти ошибки возникают при критических сбоях, таких как `Out of Memory` или `Stack Overflow`.
   - Они сигнализируют о том, что программа не может продолжить выполнение.
   - Паника (`panic`) автоматически вызывает раскрутку стека вызовов и завершает программу.

3. **Пользовательские ошибки:**
   - Можно создавать свои структуры ошибок, удовлетворяющие интерфейсу `error`, чтобы добавить контекст или хранить дополнительные данные.

---

### **Механизмы работы с ошибками**

### **1. Оборачивание и разворачивание ошибок**

- Метод `Unwrap` позволяет получить из обёрнутой ошибки исходную ошибку.
- Обёртывание делается через `%w` в `fmt.Errorf`.

### **2. Сравнение ошибок**

- `errors.Is(err, target)`:
  - Проверяет, равна ли текущая ошибка `err` заданной `target`.
- `errors.As(err, &targetType)`:
  - Проверяет, относится ли ошибка к заданному типу (например, `PathError`).

---

### **Паника (Panic)**

1. **Что такое паника?**
   - Паника (`panic`) используется для ситуаций, когда программа не может продолжить выполнение.
   - Вызывает остановку программы и начинает раскрутку стека вызовов.

2. **Когда возникает паника:**
   - Программные ошибки, которые невозможно обработать.
   - Разработчик явно вызвал `panic`.

---

### **Восстановление после паники (Recover)**

1. **Что такое `recover`?**
   - Это функция, которая позволяет перехватить панику и предотвратить аварийное завершение программы.
   - Используется внутри функций, объявленных через `defer`.

2. **Когда использовать:**
   - Для восстановления контроля над программой после возникновения паники.
   - Не рекомендуется использовать повсеместно, так как это усложняет код.

3. **Пример применения:**
   - Логирование ошибки перед завершением программы.
   - Сохранение состояния программы перед остановкой.

---

### **Лучшие практики работы с ошибками в Go**

1. **Явное возвращение ошибок:**
   - Всегда проверяйте возвращаемую ошибку и обрабатывайте её.
   - Никогда не игнорируйте `err`.

2. **Создание пользовательских ошибок:**
   - Используйте свои типы ошибок, чтобы добавить контекст.
   - Это упрощает последующую обработку или логирование.

3. **Обёртывание ошибок:**
   - Добавляйте контекст, используя `%w` в `fmt.Errorf`.
   - Это помогает понять, на каком уровне произошла ошибка.

4. **Сравнение ошибок:**
   - Используйте `errors.Is` для точного определения типа ошибки.
   - Используйте `errors.As` для работы с пользовательскими типами ошибок.

5. **Минимизация использования `panic`:**
   - Используйте паники только для критических ошибок, от которых нельзя восстановиться.
   - Для большинства ситуаций достаточно возвращения ошибки.

6. **Отслеживание стека вызовов:**
   - Для логирования стека ошибок можно использовать внешние библиотеки, такие как `pkg/errors`.

---

### **Ключевые концепции и их особенности**

| **Механизм**      | **Описание**                                                                            |
| ----------------- | --------------------------------------------------------------------------------------- |
| **error**         | Интерфейс для представления ошибок в Go.                                                |
| **fmt.Errorf**    | Используется для создания ошибок с описанием.                                           |
| **errors.Unwrap** | Извлекает вложенную ошибку.                                                             |
| **errors.Is**     | Сравнивает текущую ошибку с заданной.                                                   |
| **errors.As**     | Проверяет, соответствует ли ошибка определённому типу.                                  |
| **panic**         | Прерывает выполнение программы при критической ошибке.                                  |
| **recover**       | Восстанавливает выполнение программы после паники.                                      |
| **defer**         | Используется для выполнения кода (например, вызова `recover`) перед выходом из функции. |

---

### **Когда использовать обработку ошибок и панику**

| **Ситуация**                | **Рекомендуемый подход**                                                     |
| --------------------------- | ---------------------------------------------------------------------------- |
| Предсказуемая ошибка        | Возвращение ошибки через множественные возвращаемые значения.                |
| Критическая ошибка          | Использование `panic`.                                                       |
| Восстановление после ошибки | Использование `recover` в функции `defer`.                                   |
| Логирование ошибок          | Создание пользовательских ошибок с дополнительным контекстом и логированием. |
