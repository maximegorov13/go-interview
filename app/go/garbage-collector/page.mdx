# Garbage Collector

## Что такое сборка мусора (GC)?

Сборщик мусора — это часть **runtime**, которая автоматически управляет памятью. Его задача — освобождать память, которая больше не используется программой, чтобы предотвратить утечки памяти и оптимизировать использование ресурсов.

## Основные этапы работы GC

1. **Пометка (Mark)**
   - Сборщик мусора выполняет обход всех объектов, начиная от корневых узлов (root objects), и **помечает те, которые всё ещё используются**.
   - Это делается путём анализа всех доступных указателей.

2. **Удаление (Sweep)**
   - Все объекты, которые **не были помечены**, считаются "мёртвыми" и их память освобождается.

3. **Сжатие (Compact)**
   - Оптимизирует память путём **перемещения используемых объектов** в непрерывные области. Это снижает фрагментацию памяти.

## Алгоритм работы GC

Сборщик мусора в Go основан на **алгоритме Mark-and-Sweep (Пометка и Очистка)**, улучшенном для работы в многопоточной среде.

1. **Начальный этап (Roots)**:
   - GC начинает с корневых объектов, таких как глобальные переменные и локальные стеки горутин.

2. **Обход графа объектов**:
   - GC рекурсивно проходит по графу объектов, помечая все, до которых можно добраться.

3. **Очистка (Sweep)**:
   - Все непомеченные объекты считаются мёртвыми и удаляются.

4. **Компактизация**:
   - Перемещает живые объекты, чтобы сделать память более компактной.

## Когда запускается GC?

GC запускается автоматически в зависимости от состояния программы:

- Когда количество выделенной памяти превышает определённый порог.
- При явном вызове `runtime.GC()`.
- Периодически, чтобы предотвратить чрезмерное накопление мусора.

## Зачем нужен GC, если память используется?

Сборщик мусора позволяет:

1. Освобождать память, которая больше не нужна, даже если программист забыл это сделать.
2. Уменьшать вероятность утечек памяти.
3. Упрощать разработку, устраняя необходимость ручного управления памятью.

## Рекомендации для упрощения работы GC

1. **Сокращайте количество указателей**:
   - Чем меньше указателей, тем меньше работы для GC.

2. **Избегайте длинных цепочек ссылок**:
   - GC сложнее работать с большим количеством связанных объектов.

3. **Используйте `sync.Pool` для повторного использования объектов**:
   - Пул объектов позволяет избегать частого создания и уничтожения объектов.

4. **Минимизируйте количество временных объектов**:
   - Избыточное создание временных объектов нагружает GC.

5. **Уменьшайте количество выделений в куче**:
   - Предпочитайте стек для временных данных (используйте Escape Analysis).

## Как отключить или ограничить GC?

Отключить GC полностью нельзя, так как это часть runtime Go. Однако, можно минимизировать его влияние:

- Использовать **`sync.Pool`** для повторного использования объектов.
- Увеличивать порог использования памяти перед запуском GC с помощью `GOGC`:

```shell
  GOGC=100  # Увеличить интервал запуска GC.
```

## Трёхуровневая система разметки объектов

1. **Пометка (Mark)**:
   - GC обходит объекты и помечает те, которые связаны с корневыми узлами. Эти объекты считаются живыми.

2. **Очистка (Sweep)**:
   - Непомеченные объекты удаляются, а их память освобождается.

3. **Сжатие (Compact)**:
   - GC перемещает оставшиеся объекты в непрерывные блоки памяти, снижая фрагментацию.

## Ключевые вопросы

### 1. Как работает GC?

Сборщик мусора проходит три этапа: пометка живых объектов, очистка мёртвых и сжатие памяти.

### 2. Когда запускается GC?

Автоматически, при превышении порога памяти или по запросу через `runtime.GC()`.

### 3. Зачем нужен GC?

Для освобождения неиспользуемой памяти и предотвращения утечек.

### 4. Как упростить работу GC?

Используйте `sync.Pool`, избегайте избыточных указателей и временных объектов.

### 5. Что такое Mark-and-Sweep?

Алгоритм работы GC, который помечает живые объекты и удаляет все остальное.

### 6. Как избежать утечек памяти?

Убедитесь, что не сохраняете ненужные ссылки на объекты. Используйте профилирование для обнаружения проблем с памятью.

### 7. Можно ли отключить GC?

Нет, но его можно частично контролировать с помощью параметра `GOGC` или оптимизаций кода.

### 8. Чем отличается сборщик мусора в Go?

Сборщик мусора в Go работает параллельно, минимизируя паузы в выполнении программы.
