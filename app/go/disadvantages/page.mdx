# Недостатки Go

## 1. Управление памятью (Garbage Collection)

### Описание

- Go использует **сборщик мусора (Garbage Collector, GC)** для автоматического управления памятью.
- Несмотря на постоянные улучшения, GC может вызывать **паузы при сборке мусора**, особенно в высоконагруженных приложениях с низкой задержкой.

### Проблемы

- **Непредсказуемость пауз:** В моменты запуска GC выполнение программы может замедлиться.
- **Высокая загрузка CPU:** GC требует значительных вычислительных ресурсов для очистки неиспользуемых объектов.
- **Реальные кейсы:** Приложения с жёсткими требованиями к времени отклика (игры, трейдинг, системы реального времени) могут пострадать из-за пауз.

### Как минимизировать

- Оптимизация работы с памятью: избегать частого создания объектов.
- Использование `sync.Pool` для кэширования объектов.
- Мониторинг работы GC с помощью `runtime.ReadMemStats`.

## 2. Интерфейсы в рантайме (Runtime Type Checking)

### Описание

- В Go **интерфейсы проверяются во время выполнения**, а не на этапе компиляции.
- Это связано с тем, что Go использует **утиное типизирование**: если тип реализует все методы интерфейса, он автоматически соответствует интерфейсу.

### Проблемы

- **Отсутствие строгой проверки на этапе компиляции:** ошибки могут возникать только во время выполнения.
- **Сложность отладки:** ошибки "несоответствия типов" проявляются в рантайме, что усложняет диагностику.
- **Производительные накладные расходы:** каждая проверка интерфейса приводит к **динамическому диспетчеру типов**, что замедляет выполнение программы.

### Пример проблемы

```go showLineNumbers filename="main.go"
type Printer interface {
    Print() string
}

type Document struct {
    Content string
}

// Забытая реализация метода Print
// func (d Document) Print() string {
//    return d.Content
// }

func main() {
    var p Printer = Document{"Hello"}
    fmt.Println(p.Print())  // Паника в рантайме!
}
```

### Как минимизировать

- Использовать статические типы, когда это возможно.
- Писать тесты, проверяющие корректность интерфейсов.
- Применять автоматические линтеры (`staticcheck`, `golangci-lint`).

## 3. Неиммутабельные строки (Immutable Strings)

### Описание

- В Go строки — **неизменяемые** объекты, то есть любое изменение строки создаёт **новую копию в памяти**.
- Это обеспечивает безопасность, но увеличивает расход памяти и снижает производительность в приложениях с частой обработкой строк.

### Проблемы

- **Высокое потребление памяти:** каждое изменение создаёт новую копию строки.
- **Низкая производительность:** операции конкатенации строк (`+`, `fmt.Sprintf`) могут быть медленными.
- **Реальные кейсы:** системные журналы, обработка текстовых файлов, работа с большими объемами JSON.

### Пример проблемы

```go showLineNumbers filename="main.go"
func inefficientConcat() string {
    result := ""
    for i := 0; i < 100000; i++ {
        result += "a"  // Создаётся новая строка на каждой итерации
    }
    return result
}
```

### Как минимизировать

- Использовать `strings.Builder` для эффективной работы со строками:

  ```go showLineNumbers filename="main.go"
  import "strings"

  func efficientConcat() string {
      var builder strings.Builder
      for i := 0; i < 100000; i++ {
          builder.WriteString("a")
      }
      return builder.String()
  }
  ```

## 4. Ошибки в рантайме (Runtime Errors)

### Описание

- В Go отсутствует встроенная система исключений (`exceptions`). Вместо этого используются **паники (panic)** и **обработка ошибок (error)**, которая выполняется вручную.
- Это делает код более предсказуемым, но увеличивает **сложность обработки ошибок**.

### Проблемы

- **Нет централизованной обработки ошибок:** ошибки приходится проверять после каждой операции.
- **Много повторяющегося кода:** `if err != nil` используется практически в каждом блоке кода.
- **Паники в рантайме:** работа с `nil` указателями и массивами может вызвать **паники**, которые остановят выполнение программы, если их не перехватить.

### Пример проблемы

```go showLineNumbers filename="main.go"
func riskyOperation() {
    var p *int
    fmt.Println(*p)  // Паника из-за разыменования nil-указателя
}
```

### Как минимизировать

- Проверять все ошибки корректно.
- Использовать библиотеку `errors.Wrap()` для оборачивания ошибок с дополнительным контекстом.
- Обрабатывать паники с помощью `recover()`:

  ```go showLineNumbers filename="main.go"
  func safeOperation() {
      defer func() {
          if r := recover(); r != nil {
              fmt.Println("Возникла паника:", r)
          }
      }()
      var p *int
      fmt.Println(*p)  // Паника перехвачена
  }
  ```
